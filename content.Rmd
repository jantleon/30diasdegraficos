---
title: "#30diasdegraficos"
author: "José Antonio León Rosado"
date: "12/5/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introducción

Desde R para Ciencia de Datos han comenzado el reto de compartir un gráfico hecho con R cada día a partir del 12 de mayo. Como el objetivo de esta iniciativa es aprender sobre visualización de datos y ese es uno de mis objetivos actualmente, me voy a sumar al reto. Esta comunidad propone hashtags habitualmente en Twitter para concentrar visualizaciones y fomentar que los usuarios compartan sus gráficos. Aunque la actividad en Twitter es de R para Ciencia de Datos es muy interesante, su mayor aportación es [https://es.r4ds.hadley.nz/](la traducción del libro R para Ciencia de Datos), del creador de Tidyverse Hadley Wickham.

Para #30diasdegraficos se ha establecido el siguiente calendario:
 
![](https://pbs.twimg.com/media/EXsJ0O_WkAASkHe?format=jpg&name=medium)

Con este reto quiero poner en práctica mis habilidades con Tidyverse y, especialmente, con ggplot2, un must para para visualización de datos. ¡Allá vamos!

Lo primero que haremos será cargar Tidyverse, algo fundamental en todo análisis de datos con R y que utilizaremos todos los días del reto.

```{r tidyverse, message=FALSE, warning=FALSE}
library(tidyverse)
```

## Día 1: Gráfico de barras con datos de la API REST del Ayuntamiento de Madrid

El primer día del reto comienza con uno de los tipos de gráfico más populares y sencillos de interpretar: el gráfico de barras. Para visualizar este gráfico utilizaré la librería ggplot2 (que forma parte de Tidyverse) y los datos que publica el Ayuntamiento de Madrid sobre monumentos de la ciudad en su REST API. Como estos datos se comparten en formato JSON, necesitaremos también la librería jsonlite, que nos permite trabajar con este formato en R.

```{r loadjson, message=FALSE, warning=FALSE}
library(jsonlite)
```

Después descargo el JSON y almaceno los datos en un nuevo dataframe.

```{r loaddata, echo=FALSE}
url_json <- "https://datos.madrid.es/portal/site/egob/menuitem.ac61933d6ee3c31cae77ae7784f1a5a0/?vgnextoid=00149033f2201410VgnVCM100000171f5a0aRCRD&format=json&file=0&filename=300356-0-monumentos-ciudad-madrid&mgmtid=eb8e993ae322b610VgnVCM1000001d4a900aRCRD&preview=full"
data <- fromJSON(url_json)

data <- data[[2]][[6]]
monumentos <- data.frame(distrito = data$district[1])
monumentos <- monumentos %>% rename(distrito = 1)
```

Los nombres del distrito venían en una URL, así que hay que extraerlos a partir de la variable que contiene esas direcciones. También cambio algunos nombres de distrito para que se agrupen correctamente, ya que había algunos nombres del mismo distrito pero con la diferencia de que en unos casos aparecía con tilde y en otras sin ella (Chamartin y Chamartín, por ejemplo).

```{r tidydata}
monumentos <- monumentos %>% separate(distrito, c(NA,'distrito'), sep="Distrito/")

monumentos <- monumentos %>%
                mutate(distrito = case_when(distrito == 'Vicalvaro' ~ 'Vicálvaro',
                       distrito == 'Chamberi' ~ 'Chamberí',
                       distrito == 'Chamartin' ~ 'Chamartín',
                       distrito == 'PuenteDeVallecas' ~ 'Puente de Vallecas',
                       distrito == 'CiudadLineal' ~ 'Ciudad Lineal',
                       distrito == 'Fuencarral-ElPardo' ~ 'Fuencarral-El Pardo',
                       distrito == 'SanBlas-Canillejas' ~ 'San Blas - Canillejas',
                       distrito == 'VilladeVallecas' ~ 'Villa de Vallecas',
                       distrito == 'SanBlas' ~ 'San Blas - Canillejas',
                       distrito == 'Tetuan' ~ 'Tetuán',
                       distrito == 'VillaDeVallecas' ~ 'Villa de Vallecas',
                       TRUE ~ as.character(distrito)))
```

Creamos un tema para personalizar algunos parámetros estéticos del gráfico.

```{r theme}
theme_day1 <- function(...) 
          {theme(axis.title=element_blank(),
          text = element_text(family = "Bahnschrift"),
          axis.ticks.length = unit(-0.5, "cm"),
          axis.ticks=element_blank(),
          axis.text.x = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          strip.background = element_blank(),
          panel.background = element_rect(fill = 'white', colour = 'white'),
          plot.title = element_text(size=16, face = "bold", hjust = 0.5))
}

windowsFonts("Bahnschrift" = windowsFont("Bahnschrift"))
```

Después de algunas transformaciones, como filtrar los valores perdidos o incorrectos o calcular una variable con el número de casos para cada distrito, pintamos el gráfico con ggplot2. Como se puede ver, hemos aplicado el theme_day1 creado antes para darle una estética más atractiva que la que trae ggplot2 por defecto.

```{r plot, message=FALSE}
monumentos %>% 
  filter(!is.na(distrito) & distrito != "Distrito") %>%
  group_by(distrito) %>% 
  summarize(Count=n()) %>%
  ggplot(aes(reorder(distrito, Count), Count)) + 
    geom_bar(stat = "identity", fill = 	"deepskyblue3") +
    geom_text(aes(label=Count, family = "Bahnschrift"), hjust=-0.2, size = 3) +
    labs(title = "Número de monumentos por distrito en Madrid ", caption = "Fuente: Portal de datos abiertos del Ayuntamiento de Madrid | @jantleon") +
    theme_day1() +
    coord_flip() +
  ggsave("plots/day1.png")
    
```

## Día 2: Gráfico de líneas con la evolución de las llamadas al 016 y media móvil

Empezaremos cargando los datos, que en este caso son un .csv adaptado de una tabla del [Portal Estadístico de Violencia de Género](http://estadisticasviolenciagenero.igualdad.mpr.gob.es/) del Ministerio de Igualdad. Visualizaremos la evolución temporal de las llamadas al 016, que es un teléfono un servicio telefónico de información y de asesoramiento jurídico en materia de violencia de género que existe en España desde 2007. 

En este caso trataremos con fechas, que son un tipo de variable que puede dar algunos problemas. En este fragmento de código parseamos la fecha para que R pueda trabajar con ella y sepa que se trata de una variable de este tipo.

```{r day2_loaddata, message=FALSE, warning=FALSE}
data <- read_csv2("data/day2.csv")

data <- data %>% 
  mutate(X2 = parse_datetime(X2, format = "%d%.%m%.%Y")) %>% 
  rename(Fecha = X2, Llamadas = "Número de llamadas pertinentes")
```

Como queremos visualizar la evolución de las llamadas al 016 a lo largo del tiempo tendremos que usar un gráfico de línea. Además, para poder detectar tendencias se pintará una media móvil de 6 meses que facilita esta tarea al reducir la componente irregular de la serie y, con ello, suavizar la línea. Para este propósito utilizaremos la función "geom_ma" del paquete "tidyquant".

```{r day2_plot,, message=FALSE, warning=FALSE, fig.width = 15}
library(tidyquant)

colors <- c("Llamadas" = "darkgrey", "Media móvil (6 meses)" = "black")

data %>%
  ggplot() +
  geom_line(aes(as.Date(Fecha), Llamadas, color = "Llamadas"), size = 1.5, alpha = 0.25) +
  geom_ma(aes(as.Date(Fecha), Llamadas, color = "Media móvil (6 meses)"), n = 6, size = 1.2) +
  labs(title = "Evolución anual de las llamadas pertinentes al servicio 016 de atención telefónica a víctimas de violencia de género", caption = "Fuente: Delegación del Gobierno contra la Violencia de Género | @jantleon", color = "") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y", limits = as.Date(c('2007-10-1', '2020-5-21')), expand=c(0,0)) +
  ylab("") +
  xlab("") +
  scale_color_manual(values = colors) +
  theme_minimal(base_family = "Bahnschrift", base_size = 16) +
  ggsave("plots/day2.png", width = 18)

```

## Día 3: Gráfico de dispersión de porcentaje de obesidad por renta per cápita con inner join de tres tablas de datos

Hoy vamos a hacer un gráfico de dispersión para visualizar la relación entre el PIB per cápita y la tasa de obesidad en todo el mundo. Estos datos están dispersos en tres tablas, por lo que habrá que buscar variables comunes para hacer un inner join. Gracias a estas variables que están presentes en varios dataset a la vez, podemos combinar varias tablas sen solo una. En nuestro caso tenemos tres datasets: obesity, que contiene datos de obesidad por país (identificado por su nombre); gdp, con datos de PIB per cápita por país (también identificado por su nombre); y region, que contiene una lista de todos los países con su continente Combinando obesity con gdp en base al nombre y ésta tabla resultante con region, podemos tener un solo dataset con información sobre estas tres dimensiones por país.

Primero cargamos cada una de las tablas.

```{r day3_loaddata, message=FALSE, warning=FALSE}
obesity <- read_csv("https://raw.githubusercontent.com/owid/owid-datasets/master/datasets/Obesity%20Prevalence%20-%20WHO%20(2019)/Obesity%20Prevalence%20-%20WHO%20(2019).csv")
gdp <- read_csv("https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-05-21/per-capita-mismanaged-plastic-waste-vs-gdp-per-capita.csv")
region <- read_csv("https://raw.githubusercontent.com/lukes/ISO-3166-Countries-with-Regional-Codes/master/all/all.csv")
```

Filtramos para quedarnos solo con datos de 2016, borramos las variables innecesarias y renombramos la de renta per cápita.

```{r day3_tidydata, message=FALSE, warning=FALSE}
obesity <- obesity %>% filter(Year == 2016)
gdp <- gdp %>% filter(Year == 2016) %>% select(-c(4, 6)) %>% rename("GDP" = 4)
```

Hacemos el inner join de las tres tablas.

```{r day3_innerjoin, message=FALSE, warning=FALSE}
obegdp <- inner_join(gdp, region, by = c("Entity" = "name"))
obegdp <- inner_join(obesity, obegdp, by = "Entity") %>% rename("Year" = 2, "obesity_rate_total" = 3) %>% select(1, 2, 3, 8, 13)
```

Recodificamos la variable con la que colorearemos los puntos del gráfico de dispersión para traducir los nombres al castellano.

```{r day3_recodevariables, message=FALSE, warning=FALSE}
obegdp <- obegdp %>%
                mutate(region = case_when(region == 'Asia' ~ 'Asia',
                       region == 'Europe' ~ 'Europa',
                       region == 'Africa' ~ 'África',
                       region == 'Americas' ~ 'América',
                       region == 'Oceania' ~ 'Oceanía',
                       TRUE ~ as.character(region)))
```

Cargamos las librerías "ggrepel" (para que las etiquetas del gráfico no se solapen con los puntos con "geom_text_repel") y "ggpubr" (para mostrar el coeficiente de correlación de Pearson con "stat_cor") y visualizamos el gráfico de dispersión.

```{r day3_plot, message=FALSE, warning=FALSE}
library(ggrepel)
library(ggpubr)

obegdp %>% 
    ggplot() +
    geom_line(aes(GDP, obesity_rate_total), stat = "smooth", method ="lm", alpha = 0.3, colour = "black", se = FALSE) +
    geom_jitter(aes(GDP, obesity_rate_total, colour = region), size = 3)+
    geom_text_repel(data = subset(obegdp, obesity_rate_total > 53 | GDP > 50000), aes(GDP, obesity_rate_total, label=Entity), segment.color = NA, vjust = -1, family = "Bahnschrift") +
    stat_cor(aes(GDP, obesity_rate_total), method = "pearson", label.x = 80000, label.y = 75, family = "Bahnschrift") +
    labs(title = "Porcentaje de población con obesidad por PIB per cápita (PPA)", caption = "Fuente: Our World in Data | @jantleon", colour = "Continente") +
    ylab("% de población con obesidad") +
    xlab("PIB per cápita") +
    scale_y_continuous(limits = c(0,80)) +
    theme_minimal(base_family = "Bahnschrift", base_size = 12) +
    theme(plot.title = element_text(face = "bold")) +
    ggsave("plots/day3.png", height = 6)
```

## Día 4: Distribución de edad por equipo World Tour en la temporada 2020 (con facets y web scraping)

En esta ocasión vamos a generar un gráfico donde cada categoría se visualice en una faceta. De esta forma podremos comparar la distribución por edad de los distintos equipos ciclistas de la categoría World Tour durante la temporada 2020. 

Los datos se obtienen por web scraping de la web Pro Cycling Stats, que tiene una amplia base de datos sobre ciclismo almacenada en su propia página web. Como estos datos no están compartidos para su descarga, tenemos que rastrear el código HTML de la página para poder descargar los datos de nuestro interés. En esto consiste el web scraping y para ello hemos creado la función "get_riders", que permite descargar las variables corredor, edad, link personal con información detallada, equipo y categoría. Mediante los parámetros category y year se puede personalizar la consulta a la web para que muestre los corredores de categorías UCI, continental y femenino. En esta primera pieza de código cargamos las librerías "rvest" y "xml2" para el scraping y generamos la función "get_rider".

```{r day4_createscrapefunction, message=FALSE, warning=FALSE}
library(rvest)
library(xml2)

get_riders <- function(category, year){
url <- paste0("https://www.procyclingstats.com/teams.php&s=", category ,"&year=", year)

url_html <- read_html(url)

teams <- url_html %>% 
  html_nodes('.teamOvShirt') %>% 
  html_attr('href')

team_list <- c()

for (team in teams){
  team_list <- c(team_list, paste0("https://www.procyclingstats.com/team/", team))
}


ciclistasdf = data.frame()

for (team in team_list){
url_html <- read_html(team)

age <- url_html %>% 
    html_nodes('.age') %>%      
    html_text()

rider <- url_html %>% 
  html_nodes('.rider') %>%      
  html_text()

href <- url_html %>% 
  html_nodes('.rider') %>%
  html_attr('href')

team <- url_html %>% 
  html_nodes('.entry') %>%
  html_text()

team_df <- data.frame(rider, as.numeric(age), href, team)
ciclistasdf <- rbind(ciclistasdf, team_df)}

ciclistasdf <- ciclistasdf %>% separate(team, c("team",NA), sep ="»")
ciclistasdf <- ciclistasdf %>% separate(team, c("team","category"), sep ="\\(")

ciclistasdf <- ciclistasdf %>% mutate(category = str_sub(category, 1, str_length(category)-1))

return(ciclistasdf)
}
```

Ahora la aplicamos para la categoría World Tour (poniendo entre comillas worldtour tal como aparece en el link de la web que muestra todos los equipos) y el año 2020.

```{r day4_scrapedata, message=FALSE, warning=FALSE}
ciclistas <- get_riders("worldtour", 2020)
```
Por último, cargamos el paquete "lemon" para conservar el eje en cada facet y creamos el gráfico. Se trata de un histograma para cada equipo y una media 

```{r day4_plot, message=FALSE, warning=FALSE}
library(lemon)

ciclistas <- ciclistas %>% 
  group_by(team) %>% 
  mutate(avgage = round(mean(age),1))
    
ciclistas %>% 
  filter(category == "WT") %>% 
  ggplot(aes(age)) +
  geom_histogram(stat = "count", fill = "firebrick") +
  scale_x_continuous(breaks = seq(from = 19, to = 40, by = 3)) +
  facet_rep_wrap(~team, repeat.tick.labels = TRUE) +
  geom_text(aes(label=paste("Media:",avgage)), size = 2.5, x = 37, y = 6, family = "Bahnschrift") +
  labs(title = "Distribución de edad por equipo", subtitle ="Categoría World Tour, temporada 2020", caption = "Fuente: ProCyclingStats | @jantleon") +
  ylab("") +
  xlab("") +
  theme_minimal(base_family = "Bahnschrift", base_size = 12) +
  theme(plot.title = element_text(face = "bold")) +
  ggsave("plots/day4.png", width = 10)
```

## Día 5: Diagrama de arco con las relaciones de vecindad de las áreas sanitarias de Castilla-La Mancha

```{r}
library(arcdiagram)
library(igraph)
library(randomcoloR)

edgelist<-rbind(cbind(1:8,1:8),
      c(1,2),
      c(2,1), c(2,3), c(2,5), c(2,7),
      c(3,2), c(3,4), c(3,5), c(3,6),
      c(4,3), c(4,6),
      c(5,2), c(5,3), c(5,6), c(5,7),
      c(6,3), c(6,4), c(6,5), c(6,7), c(6,8),
      c(7,2), c(7,5), c(7,6))

# Etiquetamos los vértices
nombres_area <- c("Guadalajara", "Cuenca", "Toledo", "Talavera de la Reina", "Mancha Centro", "Ciudad Real", "Albacete", "Puertollano")

# Asignamos un tamaño a los vértices según el número de aristas que confluyen en él
degrees<-(degree(graph.edgelist(edgelist, directed = TRUE))-2)/2

# Dibujamos el gráfico de diagrama de arco
png("plots/day5.png", width = 9, height = 5, units = 'in', res = 300)
arcplot(edgelist, labels = nombres_area, lwd.arcs = 2, col.arcs = randomColor(length(edgelist),hue="blue"),
        main="Relaciones de vecindad entre las áreas sanitarias de Castilla-La Mancha",font.main=2,  
        cex.nodes = log(degrees)+0.5, col.nodes = "#b8e0f2", cex.labels = 0.6,
        sub="@jantleon", font.sub=2, cex.sub=0.4, adj = 1)
dev.off()
```

